use crate::endpoint::{Endpoint};
use crate::resource_id::{ResourceId, ResourceType};
use crate::poll::{Poll, PollRegister};
use crate::remote_addr::{RemoteAddr};
use crate::adapter::{Resource, Adapter, Remote, Listener, SendStatus, AcceptedType, ReadStatus};
use crate::util::{OTHER_THREAD_ERR};

use std::collections::{HashMap};
use std::net::{SocketAddr};
use std::sync::{Arc, RwLock};
use std::io::{self};

/// Struct used to pack the events generated by the adapter.
/// The upper layer will traduce this event into a [crate::network::NetEvent]
/// that the user can manage.
pub enum AdapterEvent<'a> {
    Added,
    Data(&'a [u8]),
    Removed,
}

pub struct ResourceRegister<S> {
    // We store the most significant addr of the resource because if the resource disconnects,
    // it can not be retrieved.
    // If the resource is a remote resource, the addr will be the peer addr.
    // If the resource is a listen resource, the addr will be the local addr.
    resources: RwLock<HashMap<ResourceId, (S, SocketAddr)>>,
    poll_register: PollRegister,
}

impl<S: Resource> ResourceRegister<S> {
    pub fn new(poll_register: PollRegister) -> ResourceRegister<S> {
        ResourceRegister { resources: RwLock::new(HashMap::new()), poll_register }
    }

    pub fn add(&self, mut resource: S, addr: SocketAddr) -> ResourceId {
        let id = self.poll_register.add(resource.source());
        self.resources.write().expect(OTHER_THREAD_ERR).insert(id, (resource, addr));
        id
    }

    pub fn remove(&self, id: ResourceId) -> Option<(S, SocketAddr)> {
        let poll_register = &self.poll_register;
        self.resources.write().expect(OTHER_THREAD_ERR).remove(&id).map(|(mut resource, addr)| {
            poll_register.remove(resource.source());
            (resource, addr)
        })
    }

    pub fn resources(&self) -> &RwLock<HashMap<ResourceId, (S, SocketAddr)>> {
        &self.resources
    }
}

pub trait ActionController {
    fn connect(&mut self, addr: RemoteAddr) -> io::Result<Endpoint>;
    fn listen(&mut self, addr: SocketAddr) -> io::Result<(ResourceId, SocketAddr)>;
    fn send(&mut self, endpoint: Endpoint, data: &[u8]) -> SendStatus;
    fn remove(&mut self, id: ResourceId) -> Option<()>;
}

pub trait EventProcessor<C>
where C: Fn(Endpoint, AdapterEvent<'_>)
{
    fn try_process(&mut self, id: ResourceId, event_callback: &mut C);
}

pub struct Driver<R: Remote, L: Listener> {
    remote_register: Arc<ResourceRegister<R>>,
    listener_register: Arc<ResourceRegister<L>>,
}

impl<R: Remote, L: Listener> Driver<R, L> {
    pub fn new(
        _: impl Adapter<Remote = R, Listener = L>,
        adapter_id: u8,
        poll: &mut Poll,
    ) -> Driver<R, L>
    {
        let remote_poll_register = poll.create_register(adapter_id, ResourceType::Remote);
        let listener_poll_register = poll.create_register(adapter_id, ResourceType::Listener);

        Driver {
            remote_register: Arc::new(ResourceRegister::<R>::new(remote_poll_register)),
            listener_register: Arc::new(ResourceRegister::<L>::new(listener_poll_register)),
        }
    }
}

impl<R: Remote, L: Listener> Clone for Driver<R, L> {
    fn clone(&self) -> Driver<R, L> {
        Driver {
            remote_register: self.remote_register.clone(),
            listener_register: self.listener_register.clone(),
        }
    }
}

impl<R: Remote, L: Listener> ActionController for Driver<R, L> {
    fn connect(&mut self, addr: RemoteAddr) -> io::Result<Endpoint> {
        let remotes = &mut self.remote_register;
        R::connect(addr).map(|(resource, addr)| Endpoint::new(remotes.add(resource, addr), addr))
    }

    fn listen(&mut self, addr: SocketAddr) -> io::Result<(ResourceId, SocketAddr)> {
        let listeners = &mut self.listener_register;
        L::listen(addr).map(|(resource, addr)| (listeners.add(resource, addr), addr))
    }

    fn send(&mut self, endpoint: Endpoint, data: &[u8]) -> SendStatus {
        match endpoint.resource_id().resource_type() {
            ResourceType::Remote => {
                let remotes = self.remote_register.resources().read().expect(OTHER_THREAD_ERR);
                match remotes.get(&endpoint.resource_id()) {
                    Some((resource, _)) => resource.send(data),

                    // TODO: currently there is not a safe way to know if this is
                    // reached because of a user API error (send over already resource removed)
                    // or because of a disconnection happened but not processed yet.
                    // It could be better to panics in the first case to distinguish
                    // the programming error from the second case.
                    None => SendStatus::ResourceNotFound,
                }
            }
            ResourceType::Listener => {
                let listeners = self.listener_register.resources().read().expect(OTHER_THREAD_ERR);
                match listeners.get(&endpoint.resource_id()) {
                    Some((resource, _)) => resource.send_to(endpoint.addr(), data),
                    None => {
                        panic!("Error: You are trying to send by a listener that does not exists")
                    }
                }
            }
        }
    }

    fn remove(&mut self, id: ResourceId) -> Option<()> {
        match id.resource_type() {
            ResourceType::Remote => self.remote_register.remove(id).map(|_| ()),
            ResourceType::Listener => self.listener_register.remove(id).map(|_| ()),
        }
    }
}

impl<C, R: Remote, L: Listener<Remote = R>> EventProcessor<C> for Driver<R, L>
where C: Fn(Endpoint, AdapterEvent<'_>)
{
    fn try_process(&mut self, id: ResourceId, event_callback: &mut C) {
        match id.resource_type() {
            ResourceType::Remote => {
                let remotes = self.remote_register.resources().read().expect(OTHER_THREAD_ERR);
                let mut to_remove: Option<Endpoint> = None;
                if let Some((resource, addr)) = remotes.get(&id) {
                    let endpoint = Endpoint::new(id, *addr);
                    let status = resource.receive(&|data| {
                        log::trace!("Read {} bytes from {}", data.len(), id);
                        event_callback(endpoint, AdapterEvent::Data(data));
                    });
                    log::trace!("Processed receive {}, for {}", status, endpoint);
                    if let ReadStatus::Disconnected = status {
                        to_remove = Some(endpoint);
                    }
                }

                drop(remotes);

                if let Some(endpoint) = to_remove {
                    self.remote_register.remove(id);
                    event_callback(endpoint, AdapterEvent::Removed);
                }
            }
            ResourceType::Listener => {
                let listeners = self.listener_register.resources().read().expect(OTHER_THREAD_ERR);

                let remotes = &mut self.remote_register;

                if let Some((resource, _)) = listeners.get(&id) {
                    resource.accept(&|accepted| {
                        log::trace!("Processed accept {} for {}", accepted, id);
                        match accepted {
                            AcceptedType::Remote(addr, remote) => {
                                let id = remotes.add(remote, addr);
                                let endpoint = Endpoint::new(id, addr);
                                event_callback(endpoint, AdapterEvent::Added);
                            }
                            AcceptedType::Data(addr, data) => {
                                let endpoint = Endpoint::new(id, addr);
                                event_callback(endpoint, AdapterEvent::Data(data));
                            }
                        }
                    });
                }
            }
        }
    }
}

impl std::fmt::Display for ReadStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let string = match self {
            ReadStatus::Disconnected => "Disconnected",
            ReadStatus::WaitNextEvent => "WaitNextEvent",
        };
        write!(f, "ReadStatus::{}", string)
    }
}

impl<R> std::fmt::Display for AcceptedType<'_, R> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let string = match self {
            AcceptedType::Remote(addr, _) => format!("AcceptedRemote({})", addr),
            AcceptedType::Data(addr, _) => format!("AcceptedData({})", addr),
        };
        write!(f, "AcceptedType::{}", string)
    }
}
